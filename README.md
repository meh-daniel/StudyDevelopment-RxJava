# StudyDevelopment-RxJava

# Что такое RxJava?

RxJava - это библиотека реактивного программирования для составления асинхронных и событийных программ с использованием наблюдаемых последовательностей.

Реактивное программирование основано на потоках данных и распространении изменений. С помощью реактивного программирования можно легко выражать статические (например, массивы) или динамические (например, излучатели событий) потоки данных.

## Объясните, как «Как будто мне пять лет», что такое RxJava?

Допустим, Донна — кассир McDonald's, и менеджер думает, что она либо крадет наличные, либо выдает неправильную сдачу. Поэтому он попросил Джоша следить за Донной и отчитываться перед ним обо всем, что она делает.

Джош внимательно наблюдал за тем, как Донна дважды выдала неправильную сдачу и по ошибке уронила некоторые изменения, так как у нее состояние подергивания руки.

Джош, будучи хорошим сотрудником, которым он является, немедленно сообщил своему менеджеру о том, как происходили события.

В этой ситуации Джош — Наблюдатель, а Донна — данные. Джошу было сказано наблюдать и сообщать Донне о том, как меняется ее состояние, и он должен сделать обратный звонок тому, кто слушает его (менеджера).

## Наглядный пример на псевдоКотлине
```kotlin
val donna: Observable<Mistakes>
val josh: Subscriber

donna = Observable.just(
  Mistakes("Wrong change"),
  Mistakes("Dropped change"),
  Mistakes("Wrong change")
)

josh = donna.subscribe({ whatHappened -> reportToMangement(whatHappened) })
```

## Теперь, где вы можете использовать RxJava?
  Существует множество мест, где вы можете использовать RxJava, и ниже приведены наиболее распространенные места, где вы можете его реализовать:
  1. Сетевые вызовы (например, вызовы API через HTTP с функцией Модернизации, которая полностью поддерживает RxJava);
  2. События пользовательского интерфейса, которые должны вызывать действия;
  3. Чтение и запись базы данных и/или файлы в системе;
  4. Данные, поступающие с датчиков;
  5. И так далее..

# База 1 - Основы

Наблюдаемый(observable) — это место, откуда исходит поток данных, он выполняет некоторую работу и выдает значения.

Оператор(operator)- имеет возможность изменять данные из одной формы в другую.

Наблюдатель(observer)- получает значения.

<img src="https://github.com/meh-daniel/StudyDevelopment-RxJava/blob/main/photo-for-readme/Observeable-operator-observer.png" width="600" height="600">

Подумайте об этом так: Наблюдаемый — это Говорящий, Оператор — Это Переводчик, а Наблюдатель — Слушатель..

## Давайте создадим Observable
Есть много способов сделать это, и мы перечислим некоторые из них ниже. Примеры могут стать несколько сложными, но не торопитесь, чтобы понять, что происходит в каждой строке.

### Just
Оператор just преобразует Item в Наблюдаемый и излучает его.
```kotlin
Observable.just("Hello Reactive World")
    .subscribe { value -> println(value) }
```
Результат:
```kotlin
Hello Reactive World
```
Давайте добавим к этому некоторую сложность. Мы хотим знать, когда элемент получен, если есть ошибка и когда она завершается.
```kotlin
Observable.just("Apple", "Orange", "Banana")
    .subscribe(
        { value -> println("Received: $value") }, // onNext
        { error -> println("Error: $error") },    // onError
        { println("Completed!") }                 // onComplete
    )
```
Результат:
```kotlin
Received: Apple
Received: Orange
Received: Banana
Completed!
```
В этой ситуации у нас есть onNext , onError , и onComplete в лямбда-выражении. Их названия в значительной степени говорят сами за себя, но я хотел бы сгенерировать ошибку, чтобы проверить ее. Не беспокойтесь о методе map на данный момент, так как мы поговорим об этом позже.
```kotlin
Observable.just("Apple", "Orange", "Banana")
    .map({ input -> throw RuntimeException() } )
    .subscribe(
        { value -> println("Received: $value") },
        { error -> println("Error: $error") },
        { println("Completed!") }
    )
```
Результат:
```kotlin
I/System.out: Error: java.lang.RuntimeException
```
